#' @title Using a QTL model, calcuate conditional QTL genotype effects
#'
#' @description
#' \code{lsmeans4qtl} Takes a QTL model, formula and returns standard
#' and SAS - style LSMeans. If the "lsmeans" package is not installed
#' means and sem are reported without least square means.
#'
#' @param cross The qtl cross object used to generate the model. Must contain genotype
#' probabilities, calculated via calc.genoprob.
#' @param pheno.col Character or numeric vector indicating the phenotype to be tested.
#' Only 1 phenotype can be tested at a time.
#' @param mod A QTL model, generated by either makeqtl (etc.) or stepwiseqtl. The model
#' must be generated using what = "prob" (makeqtl) or method = "hk".
#' @param form Character formula that must match the QTL in the fitted QTL (mod) object.
#' @param covar dataframe of covariates with names that match terms in the formula.
#' Each column must be either a character or factor. If a numeric vector was used to fit the
#' model, convert it to a factor by as.factor.
#' @param ... additional arguments passed on to lsmeans.
#' @details This function iterates through the terms in the formula, pulling out (ls)means.
#' It calls the function lsmeans from the lsmeans package, which calculates SAS-style
#' least square means. Regular means are calculated by aggregate. Genotypes for each individual
#' are inferred using the Viterbi algorithm from qtl::argmax.geno.
#' @return A dataframe of (least square) means.
#'
#' @examples
#' \dontrun{
#' library(qtlTools)
#'
#' data(fake.bc)
#' cross<-fake.bc
#' cross <- calc.genoprob(cross, step=2.5)
#'
#' # Make a QTL Model
#' mod <- makeqtl(cross, chr = c(2,5), pos = c(40,25), what = "prob")
#' nform <- "y ~ Q1 + Q2 + Q1*sex + sex"
#' sex <- data.frame(sex = as.factor(cross$phe$sex))
#' summary(fitqtl(cross, pheno.col = "pheno1", covar = data.frame(sex = cross$phe$sex),
#'    method = "hk", qtl = mod, formula = nform))
#' sex1<-pull.pheno(cross, "sex")
#'
#' # Standard Effect plot
#' effectplot(cross, pheno.col = "pheno1", mname2 = "2@40",
#'    mname1 = "Sex", mark1 = sex1, geno1 = c("F","M"))
#'
#' # Calculate lsmeans and regular means
#' sex2<-ifelse(sex1 == 0, "F","M")
#' ms<-lsmeans4qtl(cross, pheno.col = "pheno1",form = nform, mod = mod, covar=data.frame(sex = sex2))
#'
#' library(lsmeans)
#' lsms<-lsmeans4qtl(cross, pheno.col = "pheno1",form = nform, mod = mod, covar=data.frame(sex = sex2))
#' # Cull to lsmeans and regular means
#' lsms<-lsms[!is.na(lsms$Q1) & !is.na(lsms$sex),c("Q1","sex","lsmean","SE","mean","sem")]
#' library(ggplot2)
#' lms<-lsms[,c("Q1","sex","mean","sem")]
#' lms$type <- "mean"
#' lsm<-lsms[,c("Q1","sex","lsmean","SE")]
#' lsm$type<-"lsmean"
#'
#' # Put the two on top of eachother to plot in the same graph
#' colnames(lsm)[3:4]<-c("mean","se")
#' colnames(lms)[3:4]<-c("mean","se")
#' tp<-rbind(lsm,lms)
#'
#' # Make the plot
#' library(ggplot2)
#' pos<-position_dodge(.1)
#' ggplot(tp, aes(x = Q1, y = mean, shape = sex,
#'    color = sex, linetype = type, group = interaction(sex,type)))+
#'    geom_point(position = pos)+
#'    geom_line(position = pos)+
#'    theme_jtl()+
#'    geom_errorbar(aes(ymin = mean - se, ymax = mean+se), width = .1,position = pos)+
#'    ggtitle("sas-style LSMeans")
#' }
#'
#' @import qtl
#' @export
lsmeans4qtl<-function(cross, pheno.col = 1, form = NULL, mod, covar = NULL, returnData = FALSE,...){

  if(is.null(form) & is.null(attr(mod, "formula")))
      stop("formula must either be supplied, or included in mod (QTL model)\n")

  if(is.null(form))
     form <- formula(mod)

  if(any(sapply(covar, class) == "numeric"))
    stop("covariates must be either character or factor\n")

  if(length(pheno.col) != 1)
    stop("pheno.col (pheno.col) must be a numeric or character vector of length 1")

  if(!requireNamespace("lsmeans", quietly = TRUE)){
    warning("install the lsmeans package to calculate least square means\n")
  }

  # 1. parse the formula and subset the cross
  form<-as.formula(form)
  terms<-attr(terms(form), "term.labels")

  if(mod$n.ind != nind(cross)){
    warning("n individuals in cross does not match the model, subsetting the cross accordingly\n")
    cross<-subset(cross, ind = !is.na(pull.pheno(cross, pheno.col=pheno.col)))
  }

  # 2. infer the genotype for each individual at each qtl
  if("prob" %in% names(cross$geno[[1]])){
    atr<-attributes(cross$geno[[1]]$prob)
    genotypes<-attr(cross$geno[[1]]$prob,"dimnames")[[3]]
  }else{
    if("draws" %in% names(cross$geno[[1]])){
      atr<-attributes(cross$geno[[1]]$draws)
      tmp<-calc.genoprob(cross)
      genotypes<-attr(tmp$geno[[1]]$prob,"dimnames")[[3]]
    }else{
      stop("run either calc.genoprob or sim.geno first.\n")
    }
  }
  ag<-argmax.geno(cross, step = atr$step, error.prob = atr$error.prob,
                  off.end = atr$off.end, map.function = atr$map.function,
                  stepwidth = atr$stepwidth)
  gp<-pull.argmaxgeno(ag, include.pos.info=F)

  marsInMod<-find.marker(cross, chr = mod$chr, pos = mod$pos)
  gp<-data.frame(gp[,marsInMod])
  colnames(gp)<-mod$altname
  for(i in 1:length(genotypes)) gp[gp==i]<-genotypes[i]
  gp<-data.frame(gp)
  # 3. add in phenotype and covariate data
  gp$y<-pull.pheno(cross, pheno.col=pheno.col)
  if(!is.null(covar)){
    gp<-data.frame(gp, covar)
  }
  if(returnData){
    return(gp)
  }else{

    addterms<-terms[!grepl(":",terms, fixed=T)]
    # 4. calculate lsmeans for each term in model
    if(requireNamespace("lsmeans", quietly = TRUE)){
      lm.out<-lm(form,gp)
      out<-lapply(terms, function(x){
        lsmeans::lsmeans(lm.out, as.formula(paste("~",x,sep = "")))
      })

      # 5. reformat output so that it can be combined into a dataframe

      out<-lapply(out, function(x){
        x<-data.frame(summary(x))
        naterms<-addterms[!addterms %in% colnames(x)]
        for(i in naterms) x[,i]<-NA
        x<-x[,c(addterms,"lsmean", "SE", "df", "lower.CL","upper.CL")]
      })

      # 6. combine into data.frame
      out<-do.call(rbind, out)
    }


    # 7. Get generic means and ses

    sem<-function(a) sd(a, na.rm = TRUE)/sqrt(sum(!is.na(a)))
    m<-function(a) mean(a, na.rm = TRUE)
    out.mean<-lapply(terms, function(y){
      term.names = strsplit(y,":",fixed=T)[[1]]
      term = lapply(term.names, function(x) gp[,x])
      names(term)<-term.names
      am<-aggregate(gp[,"y"], term, m)
      as<-aggregate(gp[,"y"], term, sem)
      colnames(am)[which(colnames(am)=="x")]<-"mean"
      colnames(as)[which(colnames(as)=="x")]<-"sem"
      oa<-merge(as,am, by=term.names)
      for(x in addterms[!addterms %in% colnames(oa)]) oa[,x]<-NA
      oa[,c(addterms,"mean","sem")]
    })
    out.mean<-do.call(rbind, out.mean)

    if(requireNamespace("lsmeans", quietly = TRUE)){
      return(merge(out, out.mean, by = addterms))
    }else{
      return(out.mean)
    }
  }
}
