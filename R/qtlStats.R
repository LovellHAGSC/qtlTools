#' @title Extract statistics from a QTL model
#'
#' @description
#' \code{qtlStats} Takes a QTL model and calculates F-statistics, LOD scores,
#' confidence intervals, allelic means. If used in the context of eQTL mapping,
#' permits inference of whether a QTL is cis or trans.
#'
#' @param cross The qtl cross object with marker names that need to be changed.
#' @param phe Character or numeric vector indicating the phenotype to be tested
#' @param mod A QTL model, generated by either makeqtl (etc.) or stepwiseqtl.
#' @param form If a generic (not stepwiseqtl) qtl model is supplied and does
#' not contain a formula, this is required. The formula must match the QTL in the
#' fitted QTL (mod) object.
#' @param cistrans If used in an eQTL design, cis trans can be supplied as either the
#' number of the QTL in the model, e.g. Q1 = 1. Otherwise, cistrans can be specified as
#' a two-element numeric string, where the first element is the chromosome and the second is
#' the position. For example, c(1,10) indicates that this cis position of the QTL is 1@10cM. If
#' supplied, the QTL type is annotated by cis/trans position of each qtl.
#' @param ci.method The method for confidence interval estimation. Can be "drop", which
#' calls the dropint function, or "bayes", which calles the bayesint function.
#' @param drop If ci.method = "drop", this indicates the LOD score reduction that classifies
#' the interval
#' @param prob If ci.method = "bayes", this indicates the confidence interval desired
#' @param calcConfint Should confidence intervals be calculated?
#' @param calcMeans Should allelic means be calculated?
#' @param cisdist Numeric, what is the window surrounding the QTL point estimate that a QTL
#' can be called cis?
#'
#' @details This function works for riself, bc, f2 and 4-way mapping populations. It is advisable
#' to run both sim.geno and calc.genoprob prior to using qtlStats, as this will speed up the analysis.
#' Also, it is important to note that this function works best on models generated from stepwiseqtl.
#'
#' @return A dataframe of statistics.
#'
#' @examples
#' library(qtl)
#' data(fake.f2)
#' cross=fake.f2
#' fake.f2<-calc.genoprob(fake.f2)
#' covar<-matrix(pull.pheno(fake.f2,pheno.col="sex"))
#' mod=stepwiseqtl(fake.f2, max.qtl=3, method="hk", covar=covar)
#' form = "y ~ covar + Q1 + Q2 + Q3 + Q2:Q3 + Q1:covar"
#' colnames(covar)<-"covar"
#' qtlStats(cross=fake.f2, mod=mod,covar=covar,form=form,
#'          phe="phenotype", cistrans=c(1,30))
#'
#' data(fake.bc)
#' covar<-matrix(pull.pheno(fake.bc,pheno.col="sex"))
#' colnames(covar)<-"covar"
#' fake.bc<-calc.genoprob(fake.bc)
#' mod = stepwiseqtl(fake.bc, pheno.col="pheno1", max.qtl=3, method="hk", covar=covar)
#' qtlStats(cross=fake.bc, mod=mod,covar=covar,
#'          phe="pheno1", cistrans=c(1,30))
#'
#' mod = stepwiseqtl(fake.bc, pheno.col="pheno1", max.qtl=3, penalties = c(0,0,0), method="hk", covar=covar)
#' qtlStats(cross=fake.bc, mod=mod,covar=covar,
#'          phe="pheno1", cistrans=c(2,30))

#' data(fake.4way)
#' fake.4way<-calc.genoprob(fake.4way)
#' fake.4way<-sim.geno(fake.4way)
#' covar<-matrix(pull.pheno(fake.4way,pheno.col="sex"))
#' colnames(covar)<-"covar"
#' fake.bc<-calc.genoprob(fake.4way)
#' mod = stepwiseqtl(fake.4way, pheno.col="phenotype", max.qtl=3, penalties = c(3,4,3), method="hk", covar=covar)
#' qtlStats(cross=fake.4way, mod=mod,covar=covar,
#'          phe="phenotype")
#' form="y ~ covar + Q1 + Q2 + Q3 + Q1:Q3 + covar*Q1"
#' qtlStats(cross=fake.4way, mod=mod,covar=covar, form=form,
#'          phe="phenotype")
#' form="y ~ covar + Q1 + covar*Q1"
#' mod<-makeqtl(fake.4way, chr=2, pos=15)
#' qtlStats(cross=fake.4way, mod=mod,covar=covar, form=form,
#'          phe="phenotype")
#' @import qtl
#' @export

qtlStats<-function(cross,
                   mod,
                   phe,
                   cistrans = NULL,
                   covar=NULL,
                   ci.method="drop",
                   drop=1.5,
                   prob=.95,
                   form=NULL,
                   calcConfint=TRUE,
                   calcMeans=TRUE,
                   cisdist=10,
                   ...){
  if(nqtl(mod)==0 | is.null(nqtl(mod))){
    stop("error: supplied qtl object has a null model")
  }
  crossType <- class(cross)[1]
  if(class(covar) == "data.frame") covar<-as.matrix(covar)
  if(!crossType %in% c("riself", "f2", "bc", "4way")) {
    stop("error, qtlstats is only implemented for f2, bc and ril experimental designs")
  }

  if(is.null(attr(mod, "formula")) & is.null(form)){
    stop("formula must either be included in the qtl model, or supplied")
  }else{
    if(is.null(form)){
      form<- attr(mod, "formula")
    }
  }

  if(is.null(attr(mod, "lodprofile"))){
    mod<-refineqtl(cross, qtl=mod, covar=covar,  verbose=FALSE)
  }

  nqtls<-nqtl(mod)
  nterms<-sum(countqtlterms(form, ignore.covar=F)[c(1,4)])
  ncovar<-length(covar)
  nepi<-as.numeric(countqtlterms(form)[4])
  qtlnames<-mod$name

  info<-data.frame(qtlnames,
                   phenotype = phe,
                   formula = form,
                   form.name = mod$altname,
                   chr = mod$chr,
                   pos = mod$pos,
                   stringsAsFactors=F)

  fit<-fitqtl(cross,
              pheno.col=phe,
              qtl=mod,
              formula=form,
              dropone=T,
              covar=covar)

  model.stats<-data.frame(full.LOD = fit$result.full[,"LOD"][1],
                          full.percentVar = fit$result.full[,"%var"][1],
                          full.pvalue = fit$result.full[,"Pvalue(F)"][1],
                          stringsAsFactors=F)

  drop.stats<-data.frame(qtlnames = rownames(fit$result.drop),
                         form.name=attr(terms(as.formula(form)), "term.labels"),
                         fit$result.drop,
                         stringsAsFactors=F)

  out<-merge(info, drop.stats, by=c("qtlnames","form.name"), all=T)
  out$formula<-form
  out$phenotype<-phe
  out$type<-ifelse(grepl("[:]",out$form.name) & grepl("covar",out$form.name), "covar.int",
                   ifelse(grepl("[:]",out$form.name),"epi",
                          ifelse(grepl("covar",out$form.name), "covar", "add")))

  if(calcConfint){
    qtlCIs<-calcCis(mod=mod, qtlnames=qtlnames, ci.method=ci.method, drop=drop, prob=prob)
    out<-merge(out, qtlCIs, by="qtlnames", all=T)
  }

  if(calcMeans){
    qtlMeans<-calcQtlMeans(cross=cross, mod=mod, covar=covar)
    out<-merge(out, qtlMeans, by="qtlnames", all=T)
  }
  if(!is.null(cistrans)){
    out<-defineCisTrans(out=out, cistrans, cisdist=cisdist)
  }
  return(out)
}
