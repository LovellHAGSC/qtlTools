#' @title Using a QTL model, calcuate conditional QTL genotype effects
#'
#' @description
#' \code{lsmeans4qtl} Takes a QTL model, formula and returns SAS - style LSMeans.
#' *** Note: to use this function, the "lsmeans" package must be installed and loaded.
#'
#' @param cross The qtl cross object used to generate the model. Must contain genotype
#' probabilities, calculated via calc.genoprob.
#' @param phe Character or numeric vector indicating the phenotype to be tested.
#' Only 1 phenotype can be tested at a time.
#' @param mod A QTL model, generated by either makeqtl (etc.) or stepwiseqtl. The model
#' must be generated using what = "prob" (makeqtl) or method = "hk".
#' @param form Character formula that must match the QTL in the fitted QTL (mod) object.
#' @param covar dataframe of covariates with names that match terms in the formula.
#' Each column must be either a character or factor. If a numeric vector was used to fit the
#' model, convert it to a factor by as.factor.
#' @param prob.thresh The genotype probability threshold required to call a genotype. If set at
#' .5 (default) all individuals are assigned genotype calls, otherwise, those with a probability
#' < prob.threshold are called as NA. Values closer to 1 are more stringent.
#' @param ... additional arguments passed on to lsmeans.
#' @details This function iterates through the terms in the formula, pulling out lsmeans.
#' It calls the function lsmeans from the lsmeans package, which calculates SAS-style
#' least square means.
#' @return A dataframe of least square means statistics.
#'
#' @examples
#' library(qtlTools)
#' library(lsmeans)
#' cross<-fake.bc
#' cross <- calc.genoprob(cross, step=2.5)
#' mod <- makeqtl(cross, chr = c(2,5), pos = c(40,25), what = "prob")
#' nform <- "y ~ Q1 + Q2 + Q1*sex + sex"
#' sex <- data.frame(sex = as.factor(cross$phe$sex))
#' lsmeans4qtl(cross, phe = "pheno1",form = nform, mod = mod, covar=sex)
#'
#' @import qtl
#' @export
lsmeans4qtl<-function(cross, phe = 1, form = NULL, mod, covar = NULL, prob.thresh = 0, ...){

  if(is.null(form) & is.null(attr(mod, "formula")))
      stop("formula must either be supplied, or included in mod (QTL model)\n")

  if(is.null(form))
     form <- formula(mod)

  if(!"prob" %in% names(mod))
    stop("mod (QTL Model) must contain genotype probabilities\n")

  if(any(sapply(covar, class) == "numeric"))
    stop("covariates must be either character or factor\n")

  if(length(phe) != 1)
    stop("phe (pheno.col) must be a numeric or character vector of length 1")

  # 1. parse the formula and subset the cross
  form<-as.formula(form)
  terms<-attr(terms(form), "term.labels")

  if(mod$n.ind != nind(cross)){
    warning("n individuals in cross does not match the model, subsetting the cross accordingly\n")
    cross<-subset(cross, ind = !is.na(pull.pheno(cross, pheno.col=phe)))
  }

  # 2. infer the genotype for each individual at each qtl
  gp<-lapply(mod[[1]], function(x) apply(x,1, function(y) {
    if(max(y) < prob.thresh){
      return(NA)
    }else{
      return(colnames(x)[which(y==max(y))])
    }
  }))
  names(gp)<-mod$altname
  gp<-data.frame(do.call(cbind,gp))

  # 3. add in phenotype and covariate data
  gp$y<-pull.pheno(cross, pheno.col=phe)
  if(!is.null(covar)){
    gp<-data.frame(gp, covar)
  }


  # 4. calculate lsmeans for each term in model
  lm.out<-lm(form,gp)
  out<-lapply(terms, function(x){
    lsmeans(lm.out, as.formula(paste("~",x,sep = "")), ...)
  })

  # 5. reformat output so that it can be combined into a dataframe
  out<-lapply(out, function(x){
    x<-data.frame(summary(x))
    addterms<-terms[-grep(":",terms, fixed=T)]
    naterms<-addterms[!addterms %in% colnames(x)]
    for(i in naterms) x[,i]<-NA
    x<-x[,c(addterms,"lsmean", "SE", "df", "lower.CL","upper.CL")]
  })

  # 6. combine into data.frame and return
  out<-do.call(rbind, out)
  return(out)
}
